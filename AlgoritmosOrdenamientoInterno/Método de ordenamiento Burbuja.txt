/*Universidad de las Fuerzas Armadas ESPE
Tema: Metodo de ordenamiento Burbuja
Autor: Alexander Diaz, Samantha Martinez y Jhoan Salazar
Fecha de creacion: 05/07/2024
Fecha de modificacion: 07/07/2024
*/

#ifndef BUBBLESORT_H
#define BUBBLESORT_H

#include <functional>
#include <string>
using namespace std;

template <typename T, typename Nodo>
class BubbleSort {
public:
    static void bubbleSort(Nodo* primero, const std::function<bool(T*, T*)>& comparar);
    static void bubbleSortString(string& str);
};
#endif // BUBBLESORT_H



/*Universidad de las Fuerzas Armadas ESPE
Tema: Metodo de ordenamiento Burbuja
Autor: Alexander Diaz, Samantha Martinez y Jhoan Salazar
Fecha de creacion: 05/07/2024
Fecha de modificacion: 07/07/2024
*/

#include "BubbleSort.h"
#include "NodoCircular.h"

template <typename T, typename Nodo>
void BubbleSort<T, Nodo>::bubbleSort(Nodo* primero, const std::function<bool(T*, T*)>& comparar) {
    if (primero == nullptr || primero->getSiguiente() == nullptr) {
        return;
    }

    bool swapped;
    Nodo* ptr1;
    Nodo* lptr = nullptr;

    // Verificar si la lista es circular
    bool esCircular = std::is_same_v<Nodo, NodoCircular>;

    do {
        swapped = false;
        ptr1 = primero;

        while ((ptr1->getSiguiente() != lptr) && (esCircular || ptr1->getSiguiente() != nullptr)) {
            Nodo* siguiente = ptr1->getSiguiente();
            if (comparar(ptr1->getPersona(), siguiente->getPersona())) {
                T* temp = ptr1->getPersona();
                ptr1->setPersona(siguiente->getPersona());
                siguiente->setPersona(temp);
                swapped = true;
            }
            ptr1 = ptr1->getSiguiente();
        }
        lptr = ptr1;
    } while (swapped && (!esCircular || lptr != primero));
}

template <typename T, typename Nodo>
void BubbleSort<T, Nodo>::bubbleSortString(string& str) {
    int n = str.size();
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (*(str.data() + j) > *(str.data() + j + 1)) {
                char temp = *(str.data() + j);
                *(str.data() + j) = *(str.data() + j + 1);
                *(str.data() + j + 1) = temp;
            }
        }
    }
}